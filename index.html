<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tarot — 安全版（back.jpg フォールバック付き）</title>
<style>
  :root{ --bg:#000; --muted:#9aa4b2; --accent:#f6b042; --card-w:120px; --card-h:170px; }
  html,body{height:100%; margin:0;}
  body{background:var(--bg); color:#eef2f7; font-family: "Noto Sans JP", system-ui, -apple-system; padding:18px;}
  .wrap{max-width:1100px;margin:0 auto;}
  header{display:flex;align-items:center;gap:12px;justify-content:space-between}
  h1{margin:0;font-size:18px}
  .small{font-size:13px;color:var(--muted)}
  .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:12px 0}
  input[type=number]{width:80px;padding:8px;border-radius:8px;border:0;background:#07111a;color:#fff}
  button{padding:8px 12px;border-radius:8px;border:0;background:linear-gradient(180deg,var(--accent),#e89b27);color:#08101a;cursor:pointer}
  .panel{display:flex;gap:18px;align-items:flex-start;flex-wrap:wrap}
  .left{width:260px}
  .shuffle-area{width:260px;height:340px;border-radius:12px;background:linear-gradient(180deg,#071018,#041018);display:flex;align-items:center;justify-content:center;position:relative;border:1px solid rgba(255,255,255,0.03)}
  .card-frame{width:220px;height:320px;perspective:1400px}
  .card-inner{width:100%;height:100%;position:relative;transform-style:preserve-3d;transition:transform .6s}
  /* NOTE: don't set .card-back background here via CSS url() — JS will set it robustly */
  .card-back{ border-radius:12px; inset:0; position:absolute; }
  .card-face{ position:absolute; inset:0; border-radius:12px; overflow:hidden; background:#fff; }
  .card-face img{width:100%;height:100%;object-fit:cover;display:block}
  .hud{position:absolute;left:12px;bottom:12px;color:var(--muted);font-size:13px;background:rgba(0,0,0,0.32);padding:8px 10px;border-radius:10px}
  .slots{display:flex;flex-wrap:wrap;gap:12px;max-width:820px}
  .slot{width:var(--card-w);height:var(--card-h);border-radius:8px;background:linear-gradient(180deg,#06121a,#081a22);display:flex;align-items:center;justify-content:center;position:relative;border:1px solid rgba(255,255,255,0.03)}
  .slot .inner{width:100%;height:100%;border-radius:6px;position:relative;perspective:900px}
  .slot .card-inner{width:100%;height:100%;position:relative;transform-style:preserve-3d;transition:transform .6s}
  .slot .back-face,.slot .front-face{position:absolute;inset:0;border-radius:6px;backface-visibility:hidden;overflow:hidden}
  .slot .back-face{ background:linear-gradient(180deg,#0b1524,#08121a); }
  .slot .front-face{ transform: rotateY(180deg); background:#fff; }
  .slot img{width:100%;height:100%;object-fit:cover;display:block}
  .index-badge{position:absolute;left:6px;top:6px;background:rgba(0,0,0,0.6);padding:4px 6px;border-radius:6px;font-size:12px}
  .faceDown{ transform: rotateY(180deg); }
  .revealed{ transform: rotateY(0deg); }
  footer{margin-top:18px;color:var(--muted);font-size:13px}
  @media(max-width:880px){ .panel{flex-direction:column} .left{width:100%} }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>タロット — 裏向きシャッフル & 一枚ずつめくる</h1>
        <div class="small">安全版：assets パスを自動解決・画像無くてもフォールバック表示</div>
      </div>
      <div class="small" id="debugHost"></div>
    </header>

    <div class="controls">
      <label class="small">引く枚数：
        <input id="numToDraw" type="number" min="1" max="20" value="3" />
      </label>
      <button id="startSession">デッキ準備</button>
      <button id="startShuffle" disabled>シャッフル開始</button>
      <button id="stopAndDraw" disabled>STOP → 引く</button>
      <div style="margin-left:auto" class="small" id="remainingBadge">残り: --</div>
    </div>

    <div class="panel">
      <div class="left">
        <div id="shuffleArea" class="shuffle-area" title="シャッフル中は背面表示">
          <div class="card-frame">
            <div id="liveCard" class="card-inner faceDown" aria-hidden="true">
              <div id="liveBack" class="card-back"></div>
              <div class="card-face"><img id="liveFaceImg" src="" alt="card face" /></div>
            </div>
          </div>
          <div class="hud" id="hud">準備してください</div>
        </div>
        <div class="small" style="margin-top:8px">配置：<code>cards/0.jpg</code> … <code>cards/77.jpg</code> / 背面：<code>cards/back.jpg</code></div>
      </div>

      <div style="flex:1;min-width:360px">
        <div class="small">ドロー位置（左→右）</div>
        <div id="slots" class="slots" style="margin-top:10px"></div>
      </div>
    </div>

    <footer>
      <div class="small">※ サウンドは任意（`sounds/`）。GitHub Pages のサブパスでも動くようにベースURLを自動判定します。</div>
    </footer>
  </div>

<script>
/* ------------------------------
   安全対策：assets パスを自動判定して
   背面画像（back.jpg）を JS で確実にセットする実装
   ------------------------------ */

(function(){
  // Compute base URL where index.html is hosted (works for root or repo subpath)
  function computeBase() {
    // Use script src if available (most robust), else derive from location
    try {
      const curScript = document.currentScript;
      if (curScript && curScript.src) {
        return new URL('.', curScript.src).href;
      }
    } catch(e){}
    // fallback: take current location and strip filename
    return location.href.replace(/\/[^\/]*$/, '/');
  }
  const BASE = computeBase(); // ends with '/'
  // For debug display
  const dbg = document.getElementById('debugHost');
  if (dbg) dbg.textContent = 'base: ' + BASE;

  // assets paths (relative to BASE)
  const PATHS = {
    cards: BASE + 'cards/',
    sounds: BASE + 'sounds/'
  };

  // set card-back background via JS to avoid CSS path pitfalls and allow fallback
  function setCardBack() {
    const backEl = document.getElementById('liveBack');
    if (!backEl) return;
    const backUrl = PATHS.cards + 'back.jpg';
    // Use layered backgrounds: first try image, then fallback gradient
    backEl.style.backgroundImage = 'url("' + backUrl + '"), linear-gradient(180deg,#0b1524,#08121a)';
    backEl.style.backgroundSize = 'cover';
    backEl.style.backgroundPosition = 'center';
    backEl.style.backgroundRepeat = 'no-repeat';
  }

  /* ========== Core tarot logic (same as earlier but robust paths) ========== */
  const CARD_COUNT = 78;
  const DEFAULT_SHUFFLE_SPEED = 70;
  const REVEAL_DELAY = 700;

  let deck = [], drawn = [], desiredDraw = 3, shuffleTimer = null, liveIdx = 0, isShuffling = false;
  const liveCard = document.getElementById('liveCard');
  const liveFaceImg = document.getElementById('liveFaceImg');
  const hud = document.getElementById('hud');
  const startSessionBtn = document.getElementById('startSession');
  const startShuffleBtn = document.getElementById('startShuffle');
  const stopAndDrawBtn = document.getElementById('stopAndDraw');
  const slotsEl = document.getElementById('slots');
  const numToDrawEl = document.getElementById('numToDraw');
  const remainingBadge = document.getElementById('remainingBadge');

  // audio best-effort (paths use PATHS.sounds)
  const audioFiles = {
    shuffleLoop: PATHS.sounds + 'shuffle_loop.mp3',
    drawPop: PATHS.sounds + 'draw_pop.mp3',
    click: PATHS.sounds + 'select_click.mp3',
    flip: PATHS.sounds + 'flip.wav'
  };
  const audio = {};
  function loadAudio(){
    for (const k in audioFiles){
      try {
        audio[k] = new Audio(audioFiles[k]);
        audio[k].preload = 'auto';
        if (k === 'shuffleLoop') audio[k].loop = true;
      } catch(e){ audio[k] = null; }
    }
  }
  function playSound(k){
    try {
      const a = audio[k];
      if (!a) return;
      if (k === 'shuffleLoop') { if (a.paused) a.play().catch(()=>{}); }
      else { const c = a.cloneNode(true); c.play().catch(()=>{}); }
    } catch(e){}
  }
  function stopSound(k){ try { const a = audio[k]; if (a){ a.pause(); a.currentTime = 0; } } catch(e){ } }

  function cryptoShuffle(arr){ for (let i=arr.length-1;i>0;i--){ const r = crypto.getRandomValues(new Uint32Array(1))[0]; const j = r % (i+1); [arr[i],arr[j]]=[arr[j],arr[i]]; } }

  function buildDeck(){
    deck = [];
    for (let id=0; id<CARD_COUNT; id++){
      deck.push({id, orientation:'upright'});
      deck.push({id, orientation:'reversed'});
    }
    cryptoShuffle(deck);
    drawn = [];
    desiredDraw = parseInt(numToDrawEl.value) || 1;
    updateUI();
    renderSlots();
    hud.textContent = 'デッキ準備完了';
  }

  function updateUI(){
    remainingBadge.textContent = '残り: ' + deck.length;
    startShuffleBtn.disabled = deck.length === 0 || drawn.length >= desiredDraw;
  }

  function renderSlots(){
    slotsEl.innerHTML = '';
    const target = Math.max(desiredDraw, drawn.length);
    for (let i=0;i<target;i++){
      const slot = document.createElement('div'); slot.className = 'slot';
      const inner = document.createElement('div'); inner.className = 'inner';
      const cardInner = document.createElement('div'); cardInner.className = 'card-inner faceDown';
      const backFace = document.createElement('div'); backFace.className = 'back-face';
      // set backFace fallback background now (non-blocking)
      backFace.style.backgroundImage = 'linear-gradient(180deg,#0b1524,#08121a)';
      backFace.style.backgroundSize = 'cover';
      const frontFace = document.createElement('div'); frontFace.className = 'front-face';
      const img = document.createElement('img'); img.src = ''; frontFace.appendChild(img);
      cardInner.appendChild(backFace); cardInner.appendChild(frontFace);
      inner.appendChild(cardInner); slot.appendChild(inner);
      const badge = document.createElement('div'); badge.className = 'index-badge'; badge.textContent = (i+1);
      slot.appendChild(badge);
      slotsEl.appendChild(slot);
    }
  }

  function startShuffle(){
    if (deck.length === 0) { alert('まず「デッキ準備」を押してください。'); return; }
    if (drawn.length >= desiredDraw) { alert('既に指定枚数を引いています。'); return; }
    isShuffling = true;
    playSound('shuffleLoop');
    startShuffleBtn.disabled = true;
    stopAndDrawBtn.disabled = false;
    hud.textContent = 'シャッフル中…（STOPで確定）';
    // maintain back view on liveCard
    liveFaceImg.src = '';
    liveCard.classList.add('faceDown');
    liveIdx = Math.floor(Math.random() * deck.length);
    shuffleTimer = setInterval(()=>{
      if (!deck.length) return;
      liveIdx = (liveIdx + 1) % deck.length;
      const sample = deck[liveIdx];
      // preload face but keep back visible
      liveFaceImg.src = PATHS.cards + sample.id + '.jpg';
      // slight jitter
      const t = (Math.random() - 0.5) * 6;
      liveCard.style.transform = 'rotateY(180deg) translateX(' + t + 'px)';
    }, DEFAULT_SHUFFLE_SPEED);
  }

  function stopAndDraw(){
    if (!isShuffling) return;
    clearInterval(shuffleTimer); shuffleTimer = null; isShuffling = false;
    stopSound('shuffleLoop');
    startShuffleBtn.disabled = false;
    stopAndDrawBtn.disabled = true;
    liveCard.style.transform = 'rotateY(180deg)';
    const picked = deck[liveIdx];
    if (!picked) { hud.textContent = 'カードが見つかりません'; return; }
    playSound('click'); setTimeout(()=>playSound('drawPop'), 80);
    drawn.push({...picked});
    // remove pair (both orientations) from deck
    deck = deck.filter(c => c.id !== picked.id);
    updateUI();
    // set next slot's front image src (it remains faceDown for now)
    const slotIndex = drawn.length - 1;
    const slot = slotsEl.children[slotIndex];
    if (slot) {
      const cardInner = slot.querySelector('.card-inner');
      const frontImg = cardInner.querySelector('.front-face img');
      frontImg.src = PATHS.cards + picked.id + '.jpg';
      if (picked.orientation === 'reversed') cardInner.dataset.rev = 'true';
      else delete cardInner.dataset.rev;
      cardInner.classList.add('faceDown');
      // also ensure back face shows the back image (if available)
      const backFace = cardInner.querySelector('.back-face');
      if (backFace) backFace.style.backgroundImage = 'url("' + PATHS.cards + 'back.jpg"), linear-gradient(180deg,#0b1524,#08121a)';
      backFace.style.backgroundSize = 'cover';
      backFace.style.backgroundPosition = 'center';
    }
    hud.textContent = '引いた ' + drawn.length + ' 枚 / 残り ' + deck.length;
    if (drawn.length >= desiredDraw || deck.length === 0) {
      startShuffleBtn.disabled = true;
      stopAndDrawBtn.disabled = true;
      hud.textContent = '配置完了 — これから一枚ずつ表にめくります';
      setTimeout(()=>revealSequentially(), 600);
    }
  }

  async function revealSequentially(){
    for (let i=0;i<drawn.length;i++){
      const slot = slotsEl.children[i];
      if (!slot) continue;
      const cardInner = slot.querySelector('.card-inner');
      playSound('flip');
      // flip to front
      cardInner.classList.remove('faceDown');
      cardInner.classList.add('revealed');
      const frontImg = cardInner.querySelector('.front-face img');
      if (cardInner.dataset.rev === 'true') frontImg.style.transform = 'rotate(180deg)';
      else frontImg.style.transform = 'rotate(0deg)';
      await new Promise(r => setTimeout(r, REVEAL_DELAY));
    }
    hud.textContent = '全て表になりました';
  }

  // events
  numToDrawEl.addEventListener('change', ()=>{ desiredDraw = parseInt(numToDrawEl.value) || 1; renderSlots(); });
  startSessionBtn.addEventListener('click', ()=>{ desiredDraw = parseInt(numToDrawEl.value) || 1; buildDeck(); startShuffleBtn.disabled = false; stopAndDrawBtn.disabled = true; });
  startShuffleBtn.addEventListener('click', startShuffle);
  stopAndDrawBtn.addEventListener('click', stopAndDraw);
  shuffleArea.addEventListener('click', ()=>{ if (isShuffling) stopAndDraw(); else if (!startShuffleBtn.disabled) startShuffle(); });

  // initialization
  setCardBack();
  loadAudio();
  buildDeck();
  renderSlots();
  updateUI();

})();
</script>
</body>
</html>
