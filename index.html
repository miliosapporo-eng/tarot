<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tarot Draw â€” ãƒªãƒƒãƒç‰ˆï¼ˆéŸ³ & ã‚¢ãƒ‹ãƒ¡ï¼‰</title>
<style>
  :root{
    --bg:#0f1720;
    --card-bg:#fff;
    --muted:#9aa4b2;
    --accent:#f6b042;
    --panel:#0b1220;
  }
  html,body{height:100%}
  body {
    margin:0;
    padding:24px;
    font-family: "Hiragino Kaku Gothic ProN","Noto Sans JP",system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
    background: linear-gradient(180deg, #08101a 0%, #0f1720 100%);
    color:#e6eef6;
    -webkit-font-smoothing:antialiased;
  }
  header{display:flex;align-items:center;gap:16px;margin-bottom:16px}
  h1{margin:0;font-size:20px}
  .controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:14px; }
  .controls label{font-size:14px;color:var(--muted)}
  input[type=number], select{padding:8px;border-radius:8px;border:0;background:#0d1a2a;color:#e6eef6;width:80px}
  button{padding:10px 14px;border-radius:10px;border:0;background:linear-gradient(180deg,var(--accent),#e89b27);color:#08101a;font-weight:600;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,0.35)}
  button.secondary{background:transparent;color:var(--muted);box-shadow:none;border:1px solid rgba(255,255,255,0.04)}
  .panel{display:flex;gap:18px;align-items:flex-start}
  .left{width:240px}
  .shuffle-area {
    width:240px; height:340px; border-radius:14px; overflow:hidden;
    background:linear-gradient(180deg,#071019 0%, #0b1620 100%); box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    display:flex;align-items:center;justify-content:center;position:relative;border:1px solid rgba(255,255,255,0.03)
  }
  .card-frame{
    width:200px;height:300px;background:var(--card-bg);border-radius:10px;display:flex;align-items:center;justify-content:center;
    transform-origin:center; backface-visibility:hidden; overflow:hidden;
    box-shadow: 0 12px 30px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.08);
  }
  .card-frame img{max-width:100%;max-height:100%;display:block;user-select:none;pointer-events:none}
  .hud{position:absolute;left:10px;bottom:10px;color:var(--muted);font-size:13px;background:rgba(0,0,0,0.24);padding:6px 8px;border-radius:8px}
  .right{flex:1;min-width:360px}
  .slots{display:flex;flex-wrap:wrap;gap:10px}
  .slot{width:120px;height:170px;border-radius:8px;background:linear-gradient(180deg,#07111a,#071623);display:flex;align-items:center;justify-content:center;position:relative;border:1px solid rgba(255,255,255,0.03)}
  .slot .inner{width:110px;height:160px;border-radius:6px;background:linear-gradient(180deg,#0b1a29,#092035);display:flex;align-items:center;justify-content:center;overflow:hidden; transform-style:preserve-3d}
  .slot img{width:100%;height:100%;object-fit:cover;display:block;backface-visibility:hidden;transition:transform .45s cubic-bezier(.2,.9,.2,1)}
  .slot .index{position:absolute;left:8px;top:8px;background:linear-gradient(180deg,rgba(0,0,0,0.6),rgba(0,0,0,0.3));padding:3px 6px;border-radius:6px;font-size:12px}
  .muted{color:var(--muted)}
  .controls-right{display:flex;gap:8px;align-items:center;margin-left:auto}
  .volume{display:flex;gap:6px;align-items:center}
  input[type=range]{width:120px}
  /* flip animation when placing */
  .placing {
    animation: placeFlip .6s cubic-bezier(.2,.9,.2,1) forwards;
  }
  @keyframes placeFlip {
    0% { transform: rotateX(90deg) scale(1.05); opacity:0 }
    60% { transform: rotateX(-20deg) scale(1.04); opacity:1 }
    100% { transform: rotateX(0deg) scale(1); opacity:1 }
  }
  .small{font-size:13px;color:var(--muted)}
  footer{margin-top:16px;font-size:13px;color:var(--muted)}
  .speed-badge{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px;font-size:13px}
</style>
</head>
<body>
  <header>
    <h1>ã‚¿ãƒ­ãƒƒãƒˆå¼•ã â€” ãƒªãƒƒãƒç‰ˆ</h1>
    <div class="small">ã‚·ãƒ£ãƒƒãƒ•ãƒ«éŸ³ãƒ»é«˜é€Ÿã‚·ãƒ£ãƒƒãƒ•ãƒ«ãƒ»å¼•ã„ãŸã¨ãã®åŠ¹æœéŸ³ä»˜ã</div>
  </header>

  <div class="controls">
    <label>å¼•ãæšæ•°ï¼š
      <input id="numToDraw" type="number" min="1" max="20" value="3" />
    </label>
    <button id="startSession">ãƒ‡ãƒƒã‚­æº–å‚™</button>
    <button id="startShuffle" class="secondary" disabled>ã‚·ãƒ£ãƒƒãƒ•ãƒ«é–‹å§‹</button>
    <button id="toggleSpeed" class="secondary">é«˜é€Ÿåˆ‡æ›¿ï¼ˆé€šå¸¸ï¼‰</button>
    <button id="stopAndDraw" disabled>STOP â†’ å¼•ã</button>

    <div class="controls-right">
      <div class="volume small">
        ğŸ”Š
        <input id="volumeRange" type="range" min="0" max="1" step="0.01" value="0.7" />
        <button id="muteBtn" class="secondary">ãƒŸãƒ¥ãƒ¼ãƒˆ</button>
      </div>
      <div class="speed-badge" id="remainingBadge">æ®‹ã‚Šï¼š156</div>
    </div>
  </div>

  <div class="panel">
    <div class="left">
      <div class="shuffle-area" id="shuffleArea" title="ã‚·ãƒ£ãƒƒãƒ•ãƒ«ä¸­ã«STOPã§ç¢ºå®š">
        <div class="card-frame" id="cardFrame" aria-hidden="true">
          <img id="livePreview" src="" alt="card preview" />
        </div>
        <div class="hud" id="hudText">å¾…æ©Ÿä¸­</div>
      </div>
      <div class="small" style="margin-top:8px">
        ã‚·ãƒ£ãƒƒãƒ•ãƒ«è¡¨ç¤ºä¸­ã« <strong>STOP â†’ å¼•ã</strong> ã‚’æŠ¼ã™ã¨ã€è¡¨ç¤ºä¸­ã®ã‚«ãƒ¼ãƒ‰ã‚’ç¢ºå®šã—ã¾ã™ã€‚ç¢ºå®šã—ãŸã‚«ãƒ¼ãƒ‰ã®å¯¾ï¼ˆæ­£â‡„é€†ï¼‰ã¯æ®‹ã‚Šãƒ‡ãƒƒã‚­ã‹ã‚‰é™¤å»ã•ã‚Œã¾ã™ã€‚
      </div>
    </div>

    <div class="right">
      <div class="small">ãƒ‰ãƒ­ãƒ¼ä½ç½®ï¼ˆå·¦ã‹ã‚‰é †ã«ä¸¦ã³ã¾ã™ï¼‰</div>
      <div id="slots" class="slots" style="margin-top:10px"></div>
    </div>
  </div>

  <footer>
    <div class="small">ã‚«ãƒ¼ãƒ‰ç”»åƒï¼š <code>cards/0.jpg</code> â€¦ <code>cards/77.jpg</code> ã‚’æƒ³å®šã€‚éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã¯ <code>sounds/</code> ãƒ•ã‚©ãƒ«ãƒ€ã«é…ç½®ã—ã¦ãã ã•ã„ã€‚</div>
  </footer>

<script>
/* ======= è¨­å®š ======= */
const CARD_COUNT = 78;
const DEFAULT_SHUFFLE_SPEED_MS = 70;
const FAST_SHUFFLE_SPEED_MS = 24;

/* ======= çŠ¶æ…‹ ======= */
let deck = [];
let drawn = [];
let desiredDraw = 3;
let shuffleTimer = null;
let shuffleSpeed = DEFAULT_SHUFFLE_SPEED_MS;
let liveIdx = 0;
let isFast = false;
let audioEnabled = true;

/* ======= è¦ç´  ======= */
const livePreview = document.getElementById('livePreview');
const hudText = document.getElementById('hudText');
const startSessionBtn = document.getElementById('startSession');
const startShuffleBtn = document.getElementById('startShuffle');
const stopAndDrawBtn = document.getElementById('stopAndDraw');
const toggleSpeedBtn = document.getElementById('toggleSpeed');
const slotsEl = document.getElementById('slots');
const numToDrawEl = document.getElementById('numToDraw');
const remainingBadge = document.getElementById('remainingBadge');
const volumeRange = document.getElementById('volumeRange');
const muteBtn = document.getElementById('muteBtn');
const shuffleArea = document.getElementById('shuffleArea');
const cardFrame = document.getElementById('cardFrame');

/* ======= ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªæº–å‚™ï¼ˆHTMLAudioElementï¼‰ ======= */
const audioFiles = {
  shuffleLoop: 'sounds/shuffle_loop.mp3',
  drawPop: 'sounds/draw_pop.mp3',
  click: 'sounds/select_click.mp3'
};

const audio = {
  shuffleLoop: null,
  drawPop: null,
  click: null
};

function loadAudio() {
  try {
    audio.shuffleLoop = new Audio(audioFiles.shuffleLoop);
    audio.shuffleLoop.loop = true;
    audio.shuffleLoop.preload = 'auto';
    audio.drawPop = new Audio(audioFiles.drawPop);
    audio.drawPop.preload = 'auto';
    audio.click = new Audio(audioFiles.click);
    audio.click.preload = 'auto';
    setAudioVolume(volumeRange.value);
  } catch (e) {
    console.warn('Audio load failed', e);
  }
}
function setAudioVolume(v){
  const vol = Number(v);
  if (audio.shuffleLoop) audio.shuffleLoop.volume = vol;
  if (audio.drawPop) audio.drawPop.volume = vol;
  if (audio.click) audio.click.volume = vol * 0.9;
}
function playSound(key){
  if (!audioEnabled) return;
  try {
    const a = audio[key];
    if (!a) return;
    // replay policy: clone for short sounds, loop handled separately
    if (key === 'shuffleLoop') {
      // start loop if not already playing
      if (a.paused) a.play().catch(()=>{/* autoplay blocked; user interaction needed */});
    } else {
      // for clicks/pop, clone to avoid cutting off previous
      const clone = a.cloneNode(true);
      clone.volume = a.volume;
      clone.play().catch(()=>{});
    }
  } catch(e){ console.warn('playSound failed',e) }
}
function stopSound(key){
  try {
    const a = audio[key];
    if (!a) return;
    if (key === 'shuffleLoop') {
      a.pause();
      a.currentTime = 0;
    }
  } catch(e){}
}

/* ======= ãƒ©ãƒ³ãƒ€ãƒ ï¼ˆæš—å·çš„ã«å¼·ã„ã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼‰ ======= */
function cryptoShuffle(array) {
  // Fisher-Yates using crypto.getRandomValues
  for (let i = array.length - 1; i > 0; i--) {
    const r = crypto.getRandomValues(new Uint32Array(1))[0];
    const j = r % (i + 1);
    [array[i], array[j]] = [array[j], array[i]];
  }
}

/* ======= ãƒ‡ãƒƒã‚­æ§‹ç¯‰ãƒ»æ›´æ–° ======= */
function buildDeck(){
  deck = [];
  for (let id = 0; id < CARD_COUNT; id++){
    deck.push({id, orientation:'upright'});
    deck.push({id, orientation:'reversed'});
  }
  cryptoShuffle(deck);
  drawn = [];
  updateUICounts();
  renderSlots();
  hudText.textContent = 'ãƒ‡ãƒƒã‚­æº–å‚™å®Œäº†';
}

/* ======= UI æ›´æ–° ======= */
function updateUICounts(){
  remainingBadge.textContent = `æ®‹ã‚Šï¼š${deck.length}`;
  const drawnCountEl = document.getElementById('drawnCount');
  // show counts in HUD
  hudText.textContent = `æ®‹ã‚Š ${deck.length} / å¼•ã„ãŸ ${drawn.length}`;
  // disable startShuffle if finished
  startShuffleBtn.disabled = deck.length === 0 || drawn.length >= desiredDraw;
}

function renderSlots(){
  slotsEl.innerHTML = '';
  const target = Math.max(desiredDraw, drawn.length);
  for (let i=0;i<target;i++){
    const slot = document.createElement('div');
    slot.className = 'slot';
    const inner = document.createElement('div');
    inner.className = 'inner';
    if (drawn[i]) {
      const img = document.createElement('img');
      img.src = `cards/${drawn[i].id}.jpg`;
      if (drawn[i].orientation === 'reversed') img.style.transform = 'rotate(180deg)';
      inner.appendChild(img);
      slot.appendChild(inner);
      const idx = document.createElement('div');
      idx.className = 'index';
      idx.textContent = (i+1);
      slot.appendChild(idx);
    } else {
      inner.innerHTML = '<div class="small muted">ï¼ˆæœªï¼‰</div>';
      slot.appendChild(inner);
    }
    slotsEl.appendChild(slot);
  }
}

/* ======= ã‚·ãƒ£ãƒƒãƒ•ãƒ«è¡¨ç¤ºï¼ˆã‚¿ã‚¤ãƒãƒ¼ï¼‰ ======= */
function startShuffle(){
  if (deck.length === 0) { alert('ãƒ‡ãƒƒã‚­ãŒç©ºã§ã™ã€‚ã¾ãšãƒ‡ãƒƒã‚­æº–å‚™ã‚’ã—ã¦ãã ã•ã„ã€‚'); return; }
  if (drawn.length >= desiredDraw) { alert('æ—¢ã«æŒ‡å®šæšæ•°ã‚’å¼•ã„ã¦ã„ã¾ã™ã€‚'); return; }
  // start audio loop
  playSound('shuffleLoop');
  startShuffleBtn.disabled = true;
  stopAndDrawBtn.disabled = false;
  hudText.textContent = 'ã‚·ãƒ£ãƒƒãƒ•ãƒ«ä¸­â€¦ï¼ˆSTOPã§ç¢ºå®šï¼‰';

  // if deck small, ensure index within range
  liveIdx = Math.floor(Math.random() * deck.length);

  shuffleTimer = setInterval(() => {
    if (!deck.length) return;
    // rotate preview by picking next random index to create "fast flicker" effect
    liveIdx = (liveIdx + 1) % deck.length;
    const sample = deck[liveIdx];
    showPreview(sample);
    // slight jitter transform for liveliness
    const t = (Math.random() - 0.5) * 8;
    cardFrame.style.transform = `rotate(${t}deg)`;
  }, shuffleSpeed);
}

/* ======= ã‚·ãƒ£ãƒƒãƒ•ãƒ«åœæ­¢ãƒ»å¼•ãå‡¦ç† ======= */
function stopAndDraw(){
  if (!shuffleTimer) return;
  clearInterval(shuffleTimer);
  shuffleTimer = null;
  stopSound('shuffleLoop');
  startShuffleBtn.disabled = false;
  stopAndDrawBtn.disabled = true;
  cardFrame.style.transform = 'rotate(0deg)';

  // ensure liveIdx valid
  if (liveIdx < 0 || liveIdx >= deck.length) liveIdx = 0;
  const picked = deck[liveIdx];
  if (!picked) {
    hudText.textContent = 'ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
    return;
  }

  // play click / pop effects
  playSound('click');
  setTimeout(()=>playSound('drawPop'), 60);

  // push drawn (copy)
  drawn.push({...picked});

  // remove both entries with same id from deck (picked + its pair)
  deck = deck.filter(c => c.id !== picked.id);

  updateUICounts();

  // animate placement into slot
  placeCardAnimation(picked, drawn.length - 1);

  // if not finished, keep startShuffle enabled (user restart)
  if (drawn.length >= desiredDraw || deck.length === 0) {
    startShuffleBtn.disabled = true;
    stopAndDrawBtn.disabled = true;
    hudText.textContent = 'å®Œäº†';
  } else {
    hudText.textContent = `å¼•ã„ãŸ ${drawn.length} æš / æ®‹ã‚Š ${deck.length}`;
  }
}

/* ======= ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º ======= */
function showPreview(card){
  if (!card) {
    livePreview.src = '';
    livePreview.alt = '';
    return;
  }
  livePreview.src = `cards/${card.id}.jpg`;
  livePreview.alt = `Card ${card.id} (${card.orientation})`;
  if (card.orientation === 'reversed') {
    livePreview.style.transform = 'rotate(180deg)';
  } else {
    livePreview.style.transform = 'rotate(0deg)';
  }
}

/* ======= ç½®ãå ´ã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§è¿½åŠ  ======= */
function placeCardAnimation(card, slotIndex){
  // render immediate so we can animate its element
  renderSlots();
  const slot = slotsEl.children[slotIndex];
  if (!slot) return;
  const inner = slot.querySelector('.inner');
  inner.classList.add('placing');
  // set image and orientation
  const img = inner.querySelector('img');
  if (img) {
    img.src = `cards/${card.id}.jpg`;
    img.style.transform = card.orientation === 'reversed' ? 'rotate(180deg)' : 'rotate(0deg)';
  } else {
    const newImg = document.createElement('img');
    newImg.src = `cards/${card.id}.jpg`;
    newImg.style.transform = card.orientation === 'reversed' ? 'rotate(180deg)' : 'rotate(0deg)';
    inner.innerHTML = '';
    inner.appendChild(newImg);
  }
  // remove animation class after done
  setTimeout(()=> inner.classList.remove('placing'), 700);
}

/* ======= ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒ‰ ======= */
numToDrawEl.addEventListener('change', (e)=>{
  const v = parseInt(e.target.value) || 1;
  desiredDraw = Math.max(1, Math.min(20, v));
  renderSlots();
});

startSessionBtn.addEventListener('click', ()=>{
  desiredDraw = parseInt(numToDrawEl.value) || 1;
  buildDeck();
  startShuffleBtn.disabled = false;
  stopAndDrawBtn.disabled = true;
});

startShuffleBtn.addEventListener('click', ()=> {
  startShuffle();
});

stopAndDrawBtn.addEventListener('click', ()=>{
  stopAndDraw();
});

toggleSpeedBtn.addEventListener('click', ()=>{
  isFast = !isFast;
  if (isFast) {
    shuffleSpeed = FAST_SHUFFLE_SPEED_MS;
    toggleSpeedBtn.textContent = 'é«˜é€Ÿåˆ‡æ›¿ï¼ˆé«˜é€Ÿä¸­ï¼‰';
    toggleSpeedBtn.classList.remove('secondary');
    toggleSpeedBtn.style.background = 'linear-gradient(180deg,#fef3c7,#f6b042)';
  } else {
    shuffleSpeed = DEFAULT_SHUFFLE_SPEED_MS;
    toggleSpeedBtn.textContent = 'é«˜é€Ÿåˆ‡æ›¿ï¼ˆé€šå¸¸ï¼‰';
    toggleSpeedBtn.classList.add('secondary');
    toggleSpeedBtn.style.background = '';
  }
  // if currently shuffling, restart interval with new speed
  if (shuffleTimer) {
    clearInterval(shuffleTimer);
    shuffleTimer = null;
    startShuffle();
  }
});

volumeRange.addEventListener('input', (e)=>{
  setAudioVolume(e.target.value);
});

muteBtn.addEventListener('click', ()=>{
  audioEnabled = !audioEnabled;
  muteBtn.textContent = audioEnabled ? 'ãƒŸãƒ¥ãƒ¼ãƒˆ' : 'ã‚µã‚¦ãƒ³ãƒ‰ã‚ªãƒ•';
  if (!audioEnabled) {
    stopSound('shuffleLoop');
  }
});

/* allow touch on shuffle area to stop (nice UX) */
shuffleArea.addEventListener('click', ()=>{
  if (shuffleTimer) {
    // interpret tap on area as STOP
    stopAndDraw();
  } else {
    // if not shuffling but we can start, start shuffle
    if (!startShuffleBtn.disabled) startShuffle();
  }
});

/* ======= åˆæœŸå‡¦ç† ======= */
loadAudio(); // attempt to load audio resources
buildDeck();
showPreview(deck[0] || null);
renderSlots();
updateUICounts();

/* ======= è¿½åŠ æ³¨æ„ ======= */
/*
 - ãƒ–ãƒ©ã‚¦ã‚¶ã®è‡ªå‹•å†ç”Ÿãƒãƒªã‚·ãƒ¼ã§ã€ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«éŸ³ãŒå†ç”Ÿã§ããªã„å ´åˆãŒã‚ã‚Šã¾ã™ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãŒå¿…è¦ï¼‰ã€‚
   ãã®å ´åˆã¯ä¸€åº¦ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™æ“ä½œï¼ˆStartãªã©ï¼‰ãŒã‚ã‚‹ã¨å†ç”Ÿã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
 - éŸ³ãƒ•ã‚¡ã‚¤ãƒ«ãŒç„¡ã„ã¨ console ã«è­¦å‘ŠãŒå‡ºã¾ã™ãŒã€æ©Ÿèƒ½è‡ªä½“ã¯éŸ³ãªã—ã§å‹•ä½œã—ã¾ã™ã€‚
*/
</script>
</body>
</html>
